<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>4. 비동기</title>
</head>
<body>
  <!-- 
    📌 동기식(Synchronous)과 비동기식(Asynchronous)
    1. 동기식(Synchronous)
      1) 코드가 작성된 순서대로 하나씩 차례대로 실행됨
      2) 이전 작업이 끝나야 다음 작업이 실행됨
      3) 예: 일반 함수 호출, for문 등
      4) 장점
        - 코드 흐름과 실행 순서를 예측하기 쉬움
        - 디버깅이 간편함
      5) 단점
        - 하나의 작업이 오래 걸리면 전체 프로그램 흐름이 멈춤(블로킹)
        - 사용자 경험이 저하될 수 있음(예: 서버로부터 응답 대기 중 화면이 멈춤)

    2. 비동기식(Asynchronous)
      1) 코드가 즉시 실행되는 것이 아니라, 시간이 걸리는 작업은 예약해두고 먼저 다음 코드를 실행함
      2) 작업 완료 시점에 콜백 함수, Promise, async/await 등을 통해 후속 처리를 진행
      3) 예: setTimeout, AJAX, 이벤트 핸들러 등
      4) 장점
        - 오래 걸리는 작업(네트워크 요청, 파일 읽기 등) 중에도 다른 코드 실행이 가능해 전체 성능이 향상됨
        - UI가 멈추지 않고 사용자 경험이 좋아짐
      5) 단점
        - 코드 흐름의 예측이 어려워짐(순서가 보장되지 않음)
        - 콜백 지옥(Callback Hell) 등으로 코드가 복잡해질 수 있음
        - 디버깅이 상대적으로 어려움
  -->
  <h4>동기와 비동기</h4>
  <button id="sync-btn">동기</button>
  <button id="async-btn">비동기</button>
  <script>
    //동기
    document.querySelector('#sync-btn').addEventListener('click', () => {
      console.log("메인 작업시작");   //1

      console.log("부가 작업 시작(무거운 작업)");  //2
      for(let i = 0; i < 100000000; i++) {}
      console.log("부가 작업 종료(무거운 작업)");  //3    

      console.log("메인 작업 종료"); //4
    });

    //비동기
    document.querySelector('#async-btn').addEventListener('click', () => {

      console.log("메인 작업시작");   //1

      //setTimeout(콜백함수, 지연 시간(ms)) : 브라우저가 제공하는 비동기 API 중 하나

      setTimeout(() => {
        console.log("부가 작업 시작(무거운 작업)");  //3 - 1초 뒤에 실행됌 
        for(let i = 0; i < 100000000; i++) {}
        console.log("부가 작업 종료(무거운 작업)");  //4
      }, 1000); //1초 지연 후 콜백함수 실행 예약

      console.log("메인 작업 종료");  //2

    });

  </script>

  <hr>

  <h4>비동기 처리를 위한 콜백함수 사용해보기</h4>
  <button id="request-btn1">데이터 요청 후 후속작업1</button>
  <button id="request-btn2">데이터 요청 후 후속작업2</button>
  <script>
    // document.querySelector('#request-btn1').addEventListener('click', () => {
    //   console.log("메인 작업 시작");  //1

    //   setTimeout(() => {             
    //     // 데이터 요청 시뮬레이션
    //     const responseData = {name : "홍길동", age : 20} // 응답된 데이터 (JSON 객체)    //3
    //     // 후속 작업 - 응답 데이터의 이름 출력
    //     console.log(responseData.name);
    //     console.log("데이터 요청 및 후속 작업 완료"); //4

    //   }, 0); 

    //   console.log("메인 작업 종료");  //2   
     
    // });

    // 콜스택함수 먼저 실행하고 테스트큐 함수 실행 , 그래서 0초여도 콜스택함수 먼저 실행후에 setTimeout 함수 실행됨  
    // 콜스택함수, 테스트큐 함수 정의 찾아보기 ***

    // document.querySelector('#request-btn2').addEventListener('click', () => {
    //    console.log("메인 작업 시작");  //1
    //   setTimeout(() => {             
    //     // 데이터 요청 시뮬레이션
    //     const responseData = {name : "홍길동", age : 20} // 응답된 데이터 (JSON 객체)    //3
    //     // 후속 작업 - 응답 데이터의 나이 출력
    //     console.log(responseData.age);

    //   }, 0); 

    //    console.log("메인 작업 종료"); 
     
    // });


    document.querySelector('#request-btn1').addEventListener('click', () => {
      console.log("메인 작업 시작"); 

      fetchData( responseData =>  console.log(responseData.name) ); // 데이터 요청 시뮬레이션
      //resolve 함수 호출됨
      //* 작업 순서 다시 정리 

      console.log("메인 작업 종료"); 
     
    });


    document.querySelector('#request-btn2').addEventListener('click', () => {
      console.log("메인 작업 시작");  

      fetchData( (responseData) => console.log(responseData.age) ); // 데이터 요청 시뮬레이션

      console.log("메인 작업 종료"); 
    
    });

    function fetchData(resolve) { // resolve : 각 상황별로 이핼시킬 함수 전달받기(콜백함수) 
      setTimeout(() => {
        const responseData = {name : "홍길동", age : 20}; // 응답된 데이터 (JSON 객체) 
       // 후속 작업 - 응답 데이터를 활용한 (상황에 따라 다름)
       // 상황별로 이행 시킬 작업 내용이 다름 (단, 응답데이터는 동일하게 사용)
       resolve(responseData);
      }, 0); 
    }
    
  </script>

  <h4>순차적인 비동기 작업 처리 시 발생하는 콜백 지옥</h4>  
  <!-- 콜백함수안에 콜백함수 계속 중첩되는 형태 -->
  <button id="request-btn3">데이터 요청 후 후속작업1, 2 순차적으로 수행</button>
  <script>

    document.querySelector("#request-btn3").addEventListener("click", () => {
      console.log("메인 작업 시작");

      //홍길동 사람 데이터 요청 -> 응답 -> 응답데이터 중 이름 먼저 출력 -> 나이 출력 
      // 적절하지 않은 방법 => 잘 동작되는 듯 보여지지만 실제 순서를 보장하진 않음
      /*
      fetchData( responseData =>  console.log(responseData.name) );
      fetchData( responseData =>  console.log(responseData.age) );
      */

      //순차실행을 보장하기 위해서 -> 콜백 안에 콜백을 넣어야됨 (콜백지옥)
      //=> 가독성 매우 떨어짐 , 유지보수 어려움 , 디버깅 어려움
     fetchData( (responseData) => { 
        // 이름 먼저 출력
        console.log(responseData.name);
        //그다음 작업 - 나이 출력 
        // fetchData 다시 호출 -> 콜백함수 전달
        fetchData( (responseData) => {
         console.log(responseData.age)
         }); 
      })

      console.log("메인 작업 종료");
    }); 
  
  </script>

  <hr>

  <!-- 
    📌 Promise 
    1. 자바스크립트의 비동기 작업을 보다 효과적으로 처리하기 위한 객체
    2. 아직 결과는 없지만 '미래에 결과를 약속'하는 객체를 의미함 
       따라서 비동기 작업이 완료된 이후 해당 작업의 성공 또는 실패에 따른 결과값 처리를 할 수 있음 
    3. Promise의 상태 
      1) pending   : 대기 상태 (처음 생성된 직후, 아직 결과가 정해지지 않음)
      2) fulfilled : 이행 상태 (비동기 작업 성공, 결과 값을 반환)
      3) rejected  : 거부 상태 (비동기 작업 실패, 에러 값을 반환)
    4. 사용 예시 
      1) 비동기 작업을 수행하는 Promise 객체 생성 
        const promise = new Promise((resolve, reject) => { // 성공시 이행할 함수와 실패시 거부할 함수를 콜백함수로 전달받음
          // 비동기 작업 수행
          if (성공) {
            resolve(결과값); // 작업이 성공했음을 알리고 결과값 전달 
          } else {
            reject(에러값);  // 작업이 실패했음을 알리고 에러값 전달 
          }
        });
      2) 비동기 작업의 결과값 처리 
        promise
        .then((result) => {
          // 성공시 실행될 함수
        }).catch((error) => {
          // 실패시 실행될 함수
        });
    5. Promise의 장점 
      1) Promise를 활용하면 비동기 작업의 흐름을 보다 직관적이고 예측 가능하게 작성할 수 있음
      2) then(), catch() 메서드를 이용해 비동기 작업의 결과(성공/실패)를 단계별로 처리 가능
      3) 체이닝(then)을 통해 깔끔한 흐름 제어 가능 
  -->

  <h4>Promise 객체 사용하여 콜백지옥 개선</h4>
  <button id="promise-btn">데이터 요청 후 후속작업</button>
  <script>

    document.querySelector('#promise-btn').addEventListener('click', () => {  // 적는 순서 1
      console.log("메인 작업 시작");

      fetchDataByPromise()  // Promise 객체 반환되어 옴 (적는 순서 3 )
      .then((responseData) => {   //앞에 코드가 실행이 되면 그때 then 메소드 실행
        console.log("후속작업1");
        console.log(responseData.name);
        return responseData;  // then 메소드 안에서 다음 then 메소드로 데이터 전달하려면 return 사용 (적는순서4)
      }) 
      // console.log("메인 작업 종료");
      //새로운 Promise 객체 (첫번째 then 내부 콜백함수의 반환값으로 새로운 Promise 객체 생성됨)
      .then((responseData) => {   // 앞에 then 메소드가 실행이 되면 그때 then 메소드 실행
        console.log("후속작업2");
        console.log(responseData.age);
      });


      // 콜백지옥이랑 비교해서 보면됌 , 콜백지옥 개선 코드임
      console.log("메인 작업 종료");
    });

    //데이터를 가져오는 함수 => Promise 객체 활용
    function fetchDataByPromise() {   // 적는 순서 2
      return new Promise((resolve) => {
        //비동기 작업 시뮬레이션 - 데이터 요청
        const responseData = {name : "홍길동", age : 20}; // 응답된 데이터 (JSON 객체)
        resolve(responseData); // 작업 성공 시 이행 함수 호출 
      } )
    }
    
  </script>

  <hr>
  <!-- Fake API  https://jsonplaceholder.typicode.com/  -->

  <h4>실제 HTTP 통신으로 데이터 요청해보기 - XMLHttpRequest + Promise 사용</h4>
  <button id="xhr-promise-btn">게시글 데이터 요청 후 게시글 총 수 화면에 출력</button>
  <div>게시글 수: <span id="post-count">0</span></div>

  <!-- <form action="요청URL" method="요청방식(get/ post)" >
    <button>제출</button>
  </form> -->

  <script>
    // document.querySelector('#xhr-promise-btn').addEventListener('click', () => {  //1) 버튼 클릭이벤트 작성
    //   fetchDataByXMLHttpRequest()  //8 
    //   .then((responseText) => {   
    //     // console.log(responseText)
    //     JSON.parse(responseText); //9) JSON 문자열 -> JS 객체로 변환
    //   });
    // });

     document.querySelector('#xhr-promise-btn').addEventListener('click', () => {  //1) 버튼 클릭이벤트 작성
      //데이터 요청 => 응답데이터받기 => 게시글 수 카운팅 => 화면에 출력
      fetchDataByXMLHttpRequest()  //8 
       .then((responseText) => JSON.parse(responseText)) // jsonData 값을 이행하는 Promise 객체 반환
      // .then((jsonData) => console.log(jsonData.length)); //10) 게시글 총 수 출력
       .then((jsonData) => document.getElementById('#post-count').innerText = jsonData.length)    
       .catch((status) => console.error("에러 발생! 상태 코드:", status)) //11) 에러 처리
      })

    function fetchDataByXMLHttpRequest() {  // 2) XHR로 데이터 요청하는 함수 작성
      return new Promise((resolve, reject) => { // 3) 콜백함수 작성
        //XMLHttpRequest 객체 활용해서 데이터 요청 및 처리 
        // 4) 객체 생성 -> 변수 xhr 설정 
        const xhr = new XMLHttpRequest(); 
        // 5)요청 초기화 (어떤 url에 어떤 방식으로 요청할지 설정)
        // xhr.open("요청방식", "요청URL");
        xhr.open('GET', 'https://jsonplaceholder.typicode.com/posts');
        // 6) 데이터 요청작업이 완료된 시점에 수행시킬 핸들러 등록
        xhr.addEventListener('load', () => {
          // HTTP 응답 상태 코드 확인 가능
          // xhr.status => 200(성공), 404(찾을수없음), 500(서버오류) 등
          if (xhr.status === 200) { // 응답 성공인 경우
            resolve(xhr.responseText)  // =>  이행 함수로 응답 데이터 전달
          }else { // 응답 실패인 경우
            reject(xhr.status); // => 거부 함수로 에러 상태 코드 전달
          }
        })
        // 7) 요청 전송
        xhr.send();
      })
    }
    
  </script>



  <!-- 
    📌 Fetch API
    1. HTTP 파이프라인을 구성하는 요청과 응답 등의 요소를 JavaScript 에서 접근하고 조작할 수 있는 인터페이스
    2. Fetch API 가 제공하는 fetch() 전역 함수를 이용해 네트워크의 리소스를 쉽게 비동기적으로 취득할 수 있음
    3. Fetch API 는 XMLHttpRequest 와 달리 프로미스 기반으로 개선되었음
    4. fetch() 전역 함수 
      1) 네트워크에서 자원을 취득한 뒤 응답 가능 상태가 되면 이를 이행하는 프로미스를 반환하는 함수
      2) fetch() 전역 함수가 반환하는 프로미스는 요청에 대한 응답 정보를 가진 Response 객체를 이행함
      4) 사용 예시 
        fetch(resource, [options])
          .then((response) => 실행내용)
          .catch((error) => 실행내용)

        - resource : 취득하려는 리소스(자원)의 정보 (리소스의 URL 문자열 또는 Request 객체)
        - options : 리소스를 요청할 때 적용하고자 하는 사용자 지정 설정 (method, headers, body, mode, credentials 등)
        - then() : 응답 정보를 이행함수로 전달받아 실행하는 메소드
        - catch() : 응답 정보를 거부함수로 전달받아 실행하는 메소드
  -->

  <h4>실제 HTTP 통신으로 데이터 요청해보기 - Fetch API 사용</h4>
  <button id="fetch-btn">1번 게시글 데이터 요청 후 게시글의 제목 화면에 출력</button>
  <div>1번 게시글 제목: <span id="post-title"></span></div>

  <script>

    // document.querySelector('#fetch-btn').addEventListener('click', () => { 
    //   // fetch("요청할url = 취득할 자원의 주소", [요청 설정 정보]) 
    //   fetch('https://jsonplaceholder.typicode.com/posts/1') //  Promise 객체 반환 (응답정보를 담고있는 Response 객체 이행하는   Promise 객체)
    //   // .then((response) => console.log(response.json()) ) //  Promisre 객체 반환 (json 데이터 이행하는 Promise 객체)
    //   // .then((jsonData) => document.getElementById('post-title
    //   .then((response) => response.json()) //  Promisre 객체 반환 (json 데이터 이행하는 Promise 객체)
    //   // .then((jsonData) => console.log(jsonData.title));
    //   .then((jsonData) => document.getElementById('#post-title).innerText = jsonData.title);
    
    // }) 
   
  </script>

   <!-- 
    📌 async 함수와 await 문
    1. ES2017에 도입된 비동기 처리 문법
    2. 기존의 콜백과 Promise 체이닝(then)의 복잡함을 해결하기 위해 등장 
    3. 비동기 코드를 동기 코드처럼 읽기 쉽게 작성 가능 
    4. 사용 예시
      async function fetchData() {
        const response = await fetch('https://jsonplaceholder.typicode.com/posts/1');
        const jsonData = await response.json();
        document.getElementById('post-title').innerText = jsonData.title;
      }
  -->
  <h4>실제 HTTP 통신으로 데이터 요청해보기 - Fetch API + async/await 사용</h4>
  <button id="async-await-btn">1번 게시글 데이터 요청 후 게시글의 내용 화면에 출력</button>
  <div>1번 게시글 내용: <span id="post-content"></span></div>
  
  <script>
    //5) 함수 호출 
    document.querySelector('#async-await-btn').addEventListener('click', () => {
      fetchDataByAsyncAwait();  
    });

     // 1) 비동기식 함수 정의
    async function fetchDataByAsyncAwait() { 

      // 3) const response : 변수설정
      const response = await fetch('https://jsonplaceholder.typicode.com/posts/1'); // 2) fetch함수 결과 === Promise 객체를 이행하는 promise 객체 반환
      const jsonData = await response.json(); // 4) response.json() 결과 === json 데이터 이행하는 Promise 객체 반환 
      //await 대기 상태
      document.getElementById('post-content').innerText = jsonData.body; 

    }
    
  </script>

</body>
</html>